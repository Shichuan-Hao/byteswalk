# 指针

我们通过指针，可以简化一些 C++ 编程任务的执行，如动态内存分配，没有指针是无法执行的。所以，掌握好指针是成为一名优秀的 C++ 程序员的石头。

众说周知，每一个变量都有一个内存位置，每一个内存位置都定义了可使用<font color="blue">连字号运算符（&）</font>访问的地址，它表示了在内存中的一个地址。

看下面代码实例，它将输出定义的变量的地址：
```C++
#include <iostream>

using namespace std;

int main{
    int var1;
    char var2[10];

    cout << "var1 变量的地址：";
    cout << &var1 << endl;

    cout << "var2 变量的地址："
    cout << &var2 << endl;

    return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
var1 变量的地址：000000B51C1EF5E4
var2 变量的地址：000000B51C1EF608
```

通过这个例子，我们可以了解什么是内存地址以及如何访问它。

<hr/>

## 什么是指针 ？

<font color="red">指针是一个变量，它的值是另一个变量的地址，即内存位置的直接地址</font> 。与其他变量或常量一样，我们必须在使用指针存储其他变量地址之前，对其进行声明。

指针变量声明的一般形式为：
```C++
type *var-name;
```
在这里：

- **`type`** 是指针的*基类型*，它必须是一个有效的 C++ 数据类型。
- <font color="blue">一元运算符 （*）</font> 用来声明指针，与乘法中使用的星号是相同的，不过，在这个语句中，星号是用来指定一个变量是指针。
- **`var-name`** 是指针变量的名称。

下面是有效声明指针的实例：
```C++
int *ip;  /* 一个整型的指针 */
double *dp; /* 一个 double 型的指针 */
float *fp; /* 一个浮点数的指针 */
char *ch; /* 一个字符型的指针 */
```

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是代表内存地址的长的十六进制数。

不同数据类型的指针之间唯一不同的是：<font color="red">指针所指向的变量或常量的数据类型不同</font>。

<hr/>

## 在 C++ 中使用指针

使用指针时会频繁进行以下 3 个操作：

1. 定义一个指针变量。
2. 把变量地址赋值给指针。
3. 访问指针变量中可用地址的值。

这些是通过使用 <font color="blue">一元运算符 （*）</font>来返回位于操作数所指定的变量的值。下面的实例涉及到了这些操作：
```C++
#include <iostream>

using namespace std;


int main() {

	int var = 20; // 实际变量的声明
	int *ip;      // 指针变量的声明

	ip = &var;    // 在指针变量中存储 var 变量的地址

	cout << "Value of var variable: ";
	cout << var << endl;

	// 输出在指针变量中存储的地址
	cout << "Address stored in ip variable: ";
	cout << ip << endl;

	// 访问指针中地址的值
	cout << "Value of *ip variable: ";
	cout << *ip << endl;

	return 0;

}
```
当上面代码被编译和执行时，它会产生下列的结果：
```
Value of var variable: 20
Address stored in ip variable: 0000006083DDF8D4
Value of *ip variable: 20
```

## C++ Null 指针

!!! tip

    :boom: C++ 支持空指针。NULL 指针是一个定义在标准库中的值为 0 的常量。


在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 `NULL` 值是一个良好的编程习惯。赋值为 `NULL` 值的指针被称为空指针。如下面代码：

```C++
#include <iostream>

using namespace std;

int main() {

	int *ptr = NULL;

	cout << "ptr 的值是：" << ptr;

	return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：
```
ptr 的值是：0000000000000000
```

!!! Warning

    在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。但是，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但是按照惯例，如果指针包含空值（零值），就假定它不执行任何东西。

如果要检查一个空指针，我们可以使用 if 语句，如下所示：
```C++

if(ptr)   /* 如果 ptr 非空，则完成 */

if(!ptr)  /* 如果 ptr 为空，则完成 */
```

!!! Warning

    因此，如果所有未使用的指针都被赋予空值，同时避免使用空指针，就可以防止误用一个未初始化的指针。大多数情况下，未初始化的变量存有一些垃圾值，导致程序难以调试。


## C++ 指针的算术运算符

!!! tip

    :boom: 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：`++`、`--`、`+`、`-`。

假设 `ptr` 是一个指向地址 1000 的整型指针，是一个 32 位的整数，下面对该指针指向下列的算术运算：
```C++
ptr++;
```

执行 `ptr++` 后，指针 `ptr` 会向前移动 4 个字节，指向下一个整型元素的地址。这是由于指针算术运算符会根据指针的类型和大小来决定移动的距离。在这种情况下，由于是一个 32 为整数指针，每个整数占据 4 个字节，因此 `ptr++` 会将指针 ptr 向前移动 4 个字节，指向下一个整型元素的地址。

如果 `ptr` 指向一个地址为 1000 的字符，执行 `ptr++` 指针 `ptr` 的值会增加，指向下一个字符元素的地址，由于 `ptr` 是一个字符指针，每个字符占据一个字节，因此 `ptr++` 会将 `ptr` 的值增加 1，执行后 `ptr` 执行地址 1001。

!!! tip annotate "指针算术运算符的详细解析"

    1. 🚀 <font color="purple">加法运算符</font>。*可以对指针进行加法运算。当一个指针 `p` 加上一个整数 `n` 时，结果是指向 `p` 向前移动 `n` 个元素的大小。例如，如果 `p` 是一个 `int` 类型的指针，每个 `int` 占 4 个字符，那么 `p + 1` 将指向 `p` 所指向的下一个 `int` 元素。*
    2. 🚀 <font color="purple">减法运算符</font>。*可以对指针进行减法运算。当一个指针 `p` 减去一个整数 `n` 时，结果是指针 `p` 向后移动 `n` 个元素的大小。例如，如果 `p` 是一个 `int` 类型的指针，每个 `int` 占4个字节，那么 `p - 1` 将指向p所指向的前一个 `int` 元素。*
    3. 🚀 <font color="purple">指针与指针之间的减法运算</font>。*可以计算两个指针之间的距离。当从一个指针 `p` 减去另一个指针 `q` 时，结果是两个指针之间的元素个数。例如，如果 `p` 和 `q` 是两个 `int` 类型的指针，每个 `int` 占 4 个字节，那么 `p - q` 将得到两个指针之间的元素个数。*
    4. 🚀 <font color="purple">指针与整数之间的比较运算</font>。*可以将指针与整数进行比较运算。可以使用关系运算符（如 `<` 、`>`、`<=`、`>=`）对指针和整数进行比较。这种比较通常用于判断指针是否指向某个有效的内存位置。*


### 递增一个指针


### 递减一个指针

### 指针的比较

## C++ 指针 vs 数组

!!! tip

    :boom: 指针和数组之间有着密切的关系。

## C++ 指针数组

!!! tip

    :boom: 	可以定义用来存储指针的数组。

## C++ 指向指针的指针

!!! tip

    :boom: C++ 允许指向指针的指针。

## C++ 传递指针给函数

!!! tip

    :boom: 通过引用或地址传递参数，使传递的参数在调用函数中被改变。

## C++ 从函数返回指针

!!! tip

    :boom: C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。